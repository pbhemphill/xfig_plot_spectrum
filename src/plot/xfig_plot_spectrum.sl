try { require("xfig"); }
catch AnyError: {}

#ifexists xfig_plot_new

% prototype some subroutines
private define xfps_read_args();
private define xfps_setup_gaps();
private define xfps_create_xfig_object();
private define xfps_plot_data();
private define xfps_plot_model();
private define xfps_plot_res();
private define xfps_create_string_array();
private define xfps_labels();

private define __print_xfig_plot_spectrum_version() {
  variable __xfig_plot_spectrum_version = [0,9,0];
  vmessage("xfig_plot_spectrum version %s",
    strjoin(array_map(String_Type,&string,__xfig_plot_spectrum_version),"."));
}

% Minimum for (pathological) spectra with no points above zero and logarithmic
% y-axis scale
private variable XFPS_Y_DEFAULT_MINIMUM = 1e-6;
% Easier labels for axes on spectral plots
private variable XFPS_LABEL_X_KEV = "Energy (keV)";
private variable XFPS_LABEL_Y_KEV = "Counts s$^{-1}$ keV$^{-1}$";
private variable XFPS_LABEL_X_A = "Wavelength (\\AA)";
private variable XFPS_LABEL_Y_A = "Counts s$^{-1}$ \\AA$^{-1}$";

define xfig_plot_spectrum()
%%%%%%%%%%%%%%%%%%%%%
%!%+
%\function{xfig_plot_spectrum}
%\synopsis{Makes an array of slxfig objects from a set of plots saved with write_plot}
%\usage{Struct_Type[] pl = xfig_plot_spectrum(Struct_Type plt[],[...])}
%\description
%   Generates an array of SLxfig plot objects from a given set of plot data
%   structs (as generated by write_plot).
%
%   Arguments should be structs as returned by write_plot(;data). The first
%   argument should be the "best-fit" model - i.e., the spectrum and model you
%   want to plot in the top pane. Subsequent arguments should be structs
%   returned by write_plot(;data) for "intermediate" residuals (e.g. with other
%   spectral features turned on or off).
%
%   The function returns an array of SLxfig plot objects, which can then be
%   rendered using, e.g., xfig_multiplot().render. The colors, symbols,
%   linestyles, and other parameters can be adjusted using qualifiers (see
%   below). Since the xfig objects themselves are returned, you can also modify
%   them yourself after the fact (in order to, e.g., add labels or do more
%   plotting).
%
%   EXAMPLE: consider a scenario where we fit some model containing a Gaussian
%   emission line (using an "egauss" component) to a dataset of three spectra.
%   We want to create a plot that has a top pane (occupying 50% of the total
%   plot area) showing the spectrum and best-fit model, a middle pane showing
%   the residuals without the emission line, and a bottom panel showing the
%   best-fit residuals. The three spectra will be plotted in black, red, and
%   blue, with the model overplotted in green, purple, and orange, and the
%   output will be a PDF called "spectrum.pdf".
%
%   \code{
%   plot_data({1,2,3};res=1);                 % plot data and best-fit model with residuals
%   variable best = write_plot(;data);        % write plot to a structure
%   set_par("egauss(1).area",0.0,1);          % Turn off the emission line
%   () = fit_counts;                          % re-fit without the line
%   plot_data({1,2,3};res=1);                 % plot data without the line
%   variable noline = write_plot(;data);      % write the last plot to another structure
%   pl = xfig_plot_spectrum(best,noline;      % call xfig_plot_spectrum to create the xfig objects
%     colors=["black","red","blue"],          % data colors
%     mcolors=["green","purple","orange"],    % model colors
%     topPanelFrac=0.5);                      % top panel (data+model) occupies 50% of total plot area
%   xfig_multiplot(pl).render("spectrum.pdf");% render the final plot as a PDF
%   }
%
%   More qualifiers (see below) are available to fine-tune how the plot
%   appears. The colors, style, and size modifiers (dsym, symsize, mstyle,
%   mscale, dataDepth, modelDepth) can be given as arrays, with one element for
%   each spectrum plotted, or as single values, in which case each spectrum is
%   plotted with the same symbol/style/color/size.
%
%   By default, the x- and y-ranges for the resulting plot will depend on the
%   energy (or wavelength) ranges which were _noticed_ when you called
%   write_plot(). The simplest way to change the range of the resulting plot is
%   to only notice the wavelength/energy range you want to plot with xnotice()
%   or xnotice_en() - this will ensure that the y-axis and residuals scale
%   properly with what is plotted. There are also "xrange" and "yrange"
%   qualifiers to set the range of the top panel; however, the residual ranges
%   are still determined based on the full range of data.
%
%   Labels for the individual panels can be enabled via the "labels" qualifier.
%   If labels is present, but not set (or if its first element is NULL), then
%   the panels will be automatically labeled with letters starting from 'a'.
%   The "firstPanelLabel" qualifier can be used to change the starting label;
%   it should be a single letter. If the "labels" qualifier is not present at
%   all, the panels will be unlabeled. The x/y positions of the labels can be
%   set via the label_x and label_y qualifiers, which should be arrays of
%   Double_Type values indicating the positions of the lower-left corners of
%   the labels for each panel in 'world0' coordinates for that panel (see
%   'xfig_plot--wcs'). By default these are [0.94,0.95] for the data+model
%   panel and [0.94,0.78] for the residuals.
%
%   The "gaps" qualifier lets you specify where the model should not be plotted
%   (e.g., between 1.7 and 2.4 keV in the Suzaku-XIS). It should be given as a
%   List_Type list of Array_Type arrays, one array for each spectrum plotted.
%   The arrays should be a list of start and stop energies for the gaps (this
%   means they need to have even length); for instruments with no gaps, pass
%   \code{Double_Type[0]}.  E.g., for a Suzaku observation with XIS0, XIS1,
%   XIS3, and the HXD/PIN where you don't want to plot the model between 1.6
%   and 2.3 keV in the XIS spectra, you would pass
%   \code{gaps={[1.6,2.3],[1.6,2.3],[1.6,2.3],Double_Type[0]}}.
%
%   This script is mostly feature-complete, but please contact Paul Hemphill
%   (pbh@space.mit.edu) regarding bugs or missing features (please do not
%   report missing bugs; any bugs that are not present are missing
%   intentionally).
%
%\qualifiers{
%\qualifier{topPanelFrac}{: Double_Type, fraction of plot taken up by top panel, default 0.5}
%\qualifier{height}{: Double_Type, height of plot in cm, default 14.2}
%\qualifier{width}{: Double_Type, width of plot in cm, default 12.6}
%\qualifier{colors}{: String_Type[] or Integer_Type[], xfig colors for each spectrum plotted, by default uses get_sron_colors() to get a set of colors}
%\qualifier{mcolors}{: String_Type[] or Integer_Type[], xfig colors for each model plotted. By default each model is plotted with the same color as its associated data.}
%\qualifier{dsym}{: String_Type[] or Integer_Type[], xfig symbols for data for each spectrum plotted, defaults to "point"}
%\qualifier{symsize}{: Integer_Type[], size of symbols for each spectrum plotted. Can be a single value or an array (one element for each spectrum).}
%\qualifier{mstyle}{: Integer_Type[], xfig linestyle for overplotted best-fit model for each spectrum. mstyle = -1 plots the model as a histogram. As with symsize, can be single value or array. Default -1}
%\qualifier{mscale}{: Double_Type[], multiplicative scale for model (e.g., if you want to plot your model above your data points). Single value or array.}
%\qualifier{dataDepth}{: Integer_Type[], xfig depth for data points, either a single value or an array specifying the depth for each spectrum. Default 1}
%\qualifier{modelDepth}{: Integer_Type[], xfig depth for model lines. See dataDepth. Default 0 (this means models are plotted over data by default)}
%\qualifier{ratio}{: If present, residuals are ratio residuals, otherwise residuals are assumed to be some variant of data-model.}
%\qualifier{no_residuals}{If set, no residuals are plotted.}
%\qualifier{gaps}{: List_Type, indicates where gaps in an instrument's spectrum mean the model should not be plotted.}
%\qualifier{xrange}{: Double_Type[2], range for x-axis (default autoscaled)}
%\qualifier{yrange}{: Double_Type[2], range for y-axis of top panel (default autoscaled)}
%\qualifier{rrange}{: List_Type[]. Should be a list of two-element arrays containing the minimum and maximum for the y-axis of each residual plot, in the order that they appear on the plot.}
%\qualifier{xlog}{: Axes are linear by default. If "xlog" is set, or if it is set to a nonzero number, the x-axis will be logarithmic. If "xlog" is not set, or is set to zero, the x-axis will be linear.}
%\qualifier{ylog}{: See xlog; sets log/linear scale for y-axis on top panel. Residual plots always have linear y-axes.}
%\qualifier{unit}{: String_Type, either "keV" (energy, default) or "A" (wavelength).}
%\qualifier{xlabel}{: String_Type, label for x-axis, default depends on units. If unit="keV", "Energy (keV)"; if unit="A", "Wavelength (\\AA)". Set to NULL for no label.}
%\qualifier{ylabel}{: String_Type, label for y-axis of spectrum, default depends on units. If unit="keV", "Counts s$^-1$ keV$^-1$"; if unit="A", "Counts s$^{-1}$ \\AA$^{-1}$".}
%\qualifier{rlabel}{: String_Type, label for y-axis of residuals. If the "ratio" qualifier is set, default is "Ratio", otherwise default is "$\\chi$".}
%\qualifier{labels}{: String_Type[], labels for individual panels.}
%\qualifier{firstPanelLabel}{: String_Type or Integer_Type, label for first panel (further panels will increment this value, so if you give 'b' the next panels will be 'c', 'd', etc).}
%\qualifier{label_x}{: Double_Type[], x-positions (in world0 coordinates) of panel labels.}
%\qualifier{label_y}{: Double_Type[], y-positions (in world0 coordinates) of panel labels.}
%\qualifier{arrowY}{: Double_Type[2], lower and upper device coordinates for arrows for bins extending off the screen, default [0.01,0.1].}
%\qualifier{version}{: Display version information and exit.}
%}
%\seealso{write_plot, xfig_multiplot, xfig_plot_unfold, xfig_plot--wcs}
%!%-
{
  if(qualifier_exists("version") || _NARGS == 0) {
    if(qualifier_exists("version")) {
      __print_xfig_plot_spectrum_version();
      return;
    } else {
      usage("Struct_Type[] = plot_spectrum(String_Type files[],[...])");
    }
  }

  % counter variables (they're gonna be used sooner or later)
  variable i=0,j=0;

  variable spectra;
  spectra = xfps_read_args(__pop_args(_NARGS));

  variable nores = qualifier_exists("no_residuals");
  variable ratio = qualifier_exists("ratio");
  % If no_residuals is set, then we only have one panel. Otherwise, it's
  % length(spectra)+1 (i.e., the number of arguments + 1), so that we have
  % one panel for the data+model, one for each "intermediate" set of residuals,
  % and one for the best-fit residuals.
  variable nPanels = length(spectra) + 1;
  if(length(spectra[0].res[0]) == 0) nores = 1;
  if(nores) nPanels = 1;
  % spectra[0].index is an array containing the dataset indices of the
  % plotted datasets, so length(spectra[0].index) gives us the number of
  % spectra plotted.
  variable numInst = length(spectra[0].index);

  % Plot dimensions
  variable totWidth = qualifier("width",12.6);
  variable totHeight = qualifier("height",14.2);
  variable topPanelFrac = qualifier("topPanelFrac",0.5);
  % Log plots?
  variable xLog = qualifier("xlog",0);
  if(_isnull(xLog) || xLog) xLog = 1;
  variable yLog = qualifier("ylog",0);
  if(_isnull(yLog) || yLog) yLog = 1;
  % Custom ranges?
  variable xRange = qualifier("xrange",NULL);
  variable yRange = qualifier("yrange",NULL);
  variable rRange;
  if(qualifier_exists("rrange")) {
    rRange = qualifier("rrange");
  } else {
    rRange = {};
    _for i (0,nPanels-1,1)
      list_append(rRange,NULL);
  }
  % Color/style options
  % These are set up so that if the user provides a single string (rather than
  % an array) the same color/style is used for all spectra
  variable colors = qualifier("colors",get_sron_colors(numInst));
  if(typeof(colors) == String_Type or typeof(colors) == Integer_Type)
    colors = xfps_create_string_array(numInst,colors);
  variable mcolors = qualifier("mcolors",colors);
  if(typeof(mcolors) == String_Type or typeof(mcolors) == Integer_Type)
    mcolors = xfps_create_string_array(numInst,mcolors);
  variable dsym = qualifier("dsym","point");
  if(typeof(dsym) == String_Type)
    dsym = xfps_create_string_array(numInst,"point");
  variable symsize = qualifier("symsize",Double_Type[numInst]+1.0);
  if(length(symsize) == 1) symsize = Double_Type[numInst] + symsize[0];
  variable mstyle = qualifier("mstyle",Integer_Type[numInst]-1);
  if(length(mstyle) == 1) mstyle = Integer_Type[numInst] + mstyle[0];
  % Scaling for model
  variable mscale = qualifier("mscale",Double_Type[numInst]+1.0);
  if(length(mscale) == 1) mscale = Double_Type[numInst] + mscale[0];
  % Depth of model/data
  variable dataDepth = qualifier("dataDepth",Integer_Type[numInst]+1);
  if(length(dataDepth) == 1) dataDepth = Integer_Type[numInst] + dataDepth[0];
  variable modelDepth = qualifier("modelDepth",Integer_Type[numInst]);
  if(length(modelDepth) == 1) modelDepth = Integer_Type[numInst] + modelDepth[0];
  % Labels and units
  variable units = strlow(qualifier("unit","kev"));
  variable xLab = qualifier("xlabel",xfps_labels(units)[0]);
  variable yLabData = qualifier("ylabel",xfps_labels(units)[1]);
  variable yLabRes = qualifier("rlabel",(ratio ? "Ratio" : "$\\chi$"));
  variable firstPanelLabel = qualifier("firstPanelLabel",'a'); % using a char so I can increment it later
  if(typeof(firstPanelLabel) == String_Type) firstPanelLabel = firstPanelLabel[0];
  variable labelX = qualifier("label_x",Double_Type[nPanels]+0.94);
  variable labelY = qualifier("label_y",Double_Type[nPanels]+0.78); labelY[0] = 0.94;
  variable labels = String_Type[nPanels];
  if(qualifier_exists("labels")) {
    labels = qualifier("labels",NULL);
    if(_isnull(labels[0])) {
      % need to convert to strings here - not sure if slxfig will print a
      % Char_Type as a string or an integer.
      labels = array_map(String_Type,&char,[firstPanelLabel:firstPanelLabel+nPanels-1]);
    }
  }
  variable plotTitle = qualifier("title",NULL);
  % Arrows for negative lower limits on data points
  variable arrowY = qualifier("arrowY",[0.01,0.10]);
  % setting up some variables for xfig object setup later
  variable panelHeight;
  % Gaps in data?
  variable gaps = qualifier("gaps",NULL);
  gaps = xfps_setup_gaps(gaps,numInst);

  % Stick all the plot options into a struct to make subroutines easier to write
  variable plotOptions = struct{
    colors=colors,mcolors=mcolors,dsym=dsym,symsize=symsize,mstyle=mstyle,mscale=mscale,
    dataDepth=dataDepth,modelDepth=modelDepth,arrowY=arrowY,xLog=xLog,yLog=yLog,gaps=gaps,
    ratio=ratio,totWidth=totWidth,totHeight=totHeight,topPanelFrac=topPanelFrac,
    nores=nores,nPanels=nPanels,yrange=yRange,rrange=rRange,xrange=xRange
  };

  variable pl = Struct_Type[nPanels];
  variable spec;
  _for i (0,nPanels-1,1) {
    spec = struct_copy(spectra[i<nPanels-1?i:0]);
    % Set up plot object and axes' ranges
    pl[i] = xfps_create_xfig_object(spec,i,plotOptions);
    % Axes labels
    if(i==nPanels-1) pl[i].xlabel(xLab);
    pl[i].ylabel( (i==0 ? yLabData : yLabRes) );
    % Loop through spectra (there are length(spec.dval) of them) and plot data/model or residuals
    if(i==0) {
      pl[i] = xfps_plot_data(pl[i],spec,plotOptions);
      pl[i] = xfps_plot_model(pl[i],spec,plotOptions);
    } else {
      pl[i] = xfps_plot_res(pl[i],spec,plotOptions);
    }
    if(not(_isnull(labels[i])) && not(string_match(labels[i],`^[ \t\n]*$`)))
      pl[i].xylabel(labelX[i],labelY[i],labels[i],-0.5,-0.5;world0);
  }
  return pl;
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% xfps_read_args()
% Read in arguments to xfig_plot_spectrum
% In the future this should be able to read both the text files created by
% write_plot() and the structs created by write_plot(;data). Right now it only
% does the structs.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
private define xfps_read_args(args) {
  variable arg;
  variable p = Struct_Type[0];  % will store the structs containing data/model/residuals
  foreach arg (args) {
    if(typeof(arg.value) == String_Type or typeof(arg.value) == Array_Type) {
      % argument is a string or array -> read files made by write_plot()
      % for now we'll just fail because I don't want to write this yet
      % (it'll entail converting a read_data_from_write_plot() struct into the
      % struct returned by write_plot(;data) and that's just gonna be a pain)
      throw NotImplementedError,
        "*** Error: Reading files not implemented yet.",arg.value;
    } else if(typeof(arg.value) == Struct_Type) {
      % argument is a struct -> this is a struct from write_plot()
      p = [p,struct_copy(arg.value)];
    }
  }
  return p;
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% xfps_setup_gaps()
% Check and set up the "gaps" variable, which defines where gaps exist in the
% spectrum. Should result in gaps being a list of numInst zero-length arrays if
% it wasn't given.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
private define xfps_setup_gaps(gaps,numInst) {
  variable i;
  if(typeof(gaps) == List_Type and length(gaps) != numInst) {
    vmessage("Error: %i sets of gaps specified, but you have %i instruments to plot.\n",length(gaps),numInst);
    throw InvalidParmError;
  } else if (typeof(gaps) == List_Type) {
    for(i=0;i<length(gaps);i++) {
      if(length(gaps[i]) mod 2) {
        vmessage("Error: gaps for each instrument should be given as an even-length array of start and stop energies.\n");
        throw InvalidParmError;
      }
    }
  } else {
    % If gaps are not given, set to a list of zero-length arrays
    gaps = {};
    for(i=0;i<numInst;i++) list_append(gaps,Double_Type[0]);
  }
  return gaps;
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% xfps_create_xfig_object()
% Calls xfig_plot_new and sets the height and width properly.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
private define xfps_create_xfig_object(theSpectrum,i,popt) {
  variable panelWidth,panelHeight;
  variable xlo,xhi,y,dy,xmin,xmax,ymin,ymax;
  panelWidth = popt.totWidth;
  if(popt.nores) {
    panelHeight = popt.totHeight;
  } else if(i == 0) {
    panelHeight = popt.totHeight * popt.topPanelFrac;
  } else {
    panelHeight = popt.totHeight * (1.0-popt.topPanelFrac)/(double(popt.nPanels-1));
  }
  if(_isnull(popt.xrange)[0]) {
    xmin = min(array_flatten(theSpectrum.dlo));
    xmax = max(array_flatten(theSpectrum.dhi));
  } else {
    xmin = popt.xrange[0];
    xmax = popt.xrange[1];
  }
  if(i != 0) { % working on residuals
    variable rrange;
    if(_isnull(popt.rrange[i-1])) {
      variable j;
      variable rmin = Double_Type[0];
      variable rmax = Double_Type[0];
      _for j (0,length(theSpectrum.res)-1,1) {
        rmin = [rmin,theSpectrum.res_m[j][0]];
        rmax = [rmax,theSpectrum.res_p[j][0]];
      }
      ymin = min(rmin);
      ymax = max(rmax);
    } else {
      ymin = popt.rrange[i-1][0];
      ymax = popt.rrange[i-1][1];
    }
  } else { % working on data
    if(_isnull(popt.yrange)[0]) {
      % We want to scale to the noticed x-range, not the full range.
      % First, we grab the x-axis values and compare them to the x-range, which was set above.
      xlo = array_flatten(theSpectrum.dlo);
      xhi = array_flatten(theSpectrum.dhi);
      variable ndx = where(xlo >= xmin and xhi <= xmax); 
      % Then, we grab the y-values and their errors and select only the ones that are within [xmin,xmax]
      dy = array_flatten(theSpectrum.derr)[ndx];
      y = array_flatten(theSpectrum.dval)[ndx];
      % The maximum is easy in any scenario - it's just the largest value.
      % (unless you gave me a spectrum with all negative numbers, I'm now
      % realizing. Please don't do that?)
      ymax = max(y+dy);
      % For the minimum, if the y-axis isn't logarithmic, we're fine - we just
      % take the smallest value and call it a day.
      if(not(popt.yLog)) {
        ymin = min(y-dy);
      } else {
        % But if the y-axis is log-scaled, we need to get rid of anything <= 0.
        ymin = y-dy;
        % First try to find places where y-dy is above 0 and use the smallest one of those
        if(length(where(ymin >= 0.))) {
          ymin = min(ymin[where(ymin >= 0.)]);
        } else {
          % If that fails, find places where y is greater than zero
          ymin = y;
          if(length(where(ymin >= 0.))) {
            ymin = min(ymin[where(ymin >= 0.)]);
          } else {
            % Otherwise, use some sort of hard minimum.
            % Note that if we get to this point, we're just going to be
            % plotting a bunch of downward arrows, because everything will be
            % off the scale.
            ymin = XFPS_Y_DEFAULT_MINIMUM;
            message("*** Warning: No data points greater than zero and logarithmic y-axis requested.");
          }
        }
      }
    } else {
      ymin = popt.yrange[0];
      ymax = popt.yrange[1];
    }
  }
  % print(sprintf("xmin = %f, xmax = %f, ymin = %f, ymax = %f",xmin,xmax,ymin,ymax));
  variable pltemp = xfig_plot_new(panelWidth,panelHeight);
  pltemp.world(xmin,xmax,ymin,ymax;xlog=popt.xLog,ylog=(i==0?popt.yLog:0),pady=0.1);
  return pltemp;
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% xfps_plot_data()
% Plots data on provided xfig plot object
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
private define xfps_plot_data(pl,spec,popt) {
  variable j;
  _for j (0,length(spec.dval)-1,1) {
    variable dlo,dhi,dval,derr;
    dlo = spec.dlo[j];
    dhi = spec.dhi[j];
    dval = spec.dval[j];
    derr = spec.derr[j];
    % Also get the mins/maxes from the xfig object:
    variable w = pl.get_world(); % w is [xmin,xmax,ymin,ymax]
    % First, only plot points which are above ymin and below ymax
    variable ndx = where(dval-derr >= w[-2] and dval+derr <= w[-1]);
    if(length(ndx))
      pl.plot((dlo[ndx]+dhi[ndx])/2.0,dval[ndx],{dlo[ndx],dhi[ndx]},derr[ndx];
        xminmax,sym=popt.dsym[j],size=popt.symsize[j],color=popt.colors[j],
        depth=popt.dataDepth[j]);

    variable k; % counter
    variable x,y,ymin,ymax; % for arrow coords
    % Now plot arrows for anything that extends below ymin:
    ndx = where(dval-derr <= w[-2]);
    if(length(ndx)) {
      % plot the points _without error bars_ first
      pl.plot((dlo[ndx]+dhi[ndx])/2.0,dval[ndx];sym=popt.dsym[j],size=popt.symsize[j],color=popt.colors[j],depth=popt.dataDepth[j]);
      % then draw a downward arrow - down to arrowY[0] of the way from the
      % bottom axis, starting either at the top of the error bar or arrowY[1]
      % of the way from the bottom axis, whichever is larger
      _for k (0,length(ndx)-1,1) {
        x = (dlo[ndx[k]]+dhi[ndx[k]])/2.0;
        y = dval[ndx[k]];
        ymin = popt.arrowY[0];
        ymax = popt.arrowY[1];
        pl.plot([x,x],[ymax,ymin];world10,size=popt.symsize[j],color=popt.colors[j],depth=popt.dataDepth[j],forward_arrow);
      }
    }
    % And same for anything that extends above ymax:
    ndx = where(dval+derr >= w[-1]);
    if(length(ndx)) {
      % plot the points _without error bars_ first
      pl.plot((dlo[ndx]+dhi[ndx])/2.0,dval[ndx];sym=popt.dsym[j],size=popt.symsize[j],color=popt.colors[j],depth=popt.dataDepth[j]);
      % then draw an upward arrow - up to arrowY[0] of the way from the
      % top axis, starting either at the bottom of the error bar or arrowY[1]
      % of the way from the top axis, whichever is smaller
      _for k (0,length(ndx)-1,1) {
        x = (dlo[ndx[k]]+dhi[ndx[k]])/2.0;
        y = dval[ndx[k]];
        ymin = 1.0-popt.arrowY[1];
        ymax = 1.0-popt.arrowY[0];
        pl.plot([x,x],[ymin,ymax];world10,size=popt.symsize[j],color=popt.colors[j],depth=popt.dataDepth[j],forward_arrow);
      }
    }
  }
  return pl;
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% xfps_plot_model()
% Plots model on provided xfig plot object
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
private define xfps_plot_model(pl,spec,popt) {
  variable j;
  _for j (0,length(spec.dval)-1,1) {
    % If spec.mval[j] is NULL, then there's no model! Only keep going if that's not the case!
    if(not(_isnull(spec.mval[j])[0])) {
      variable dlo,dhi,mval;
      dlo = spec.dlo[j];
      dhi = spec.dhi[j];
      mval = spec.mval[j] * popt.mscale[j];
      % Loop through gaps[j] two elements at a time, getting the starting and
      % ending points where we should plot the model.
      % I.e., if gaps[j] is [1.6,2.3], we want to plot the model in the ranges
      % [emin,1.6) and (2.3,emax].
      % If length(gaps[j]) is zero, we still run through this loop once (since
      % we start with k = -1).
      variable k,mstart,mend,ndx;
      _for k (-1,length(popt.gaps[j])-1,2) {
        if(length(popt.gaps[j]) == 0) {
          mstart = min(dlo)-1.0;% subtract 1 just so we know we get all the points
          mend = max(dhi)+1.0;  % add 1 just so we know we get all the points
        } else if(k == -1) {
          mstart = min(dlo)-1.0;
          mend = popt.gaps[j][k+1];
        } else if (k == length(popt.gaps[j])-1) {
          mstart = popt.gaps[j][k];
          mend = max(dhi)+1.0;
        } else {
          mstart = popt.gaps[j][k];
          mend = popt.gaps[j][k+1];
        }
        ndx = where(dlo >= mstart and dhi <= mend);
        if(popt.mstyle[j] == -1) {
          pl.hplot(dlo[ndx],mval[ndx];
            color=popt.mcolors[j],depth=popt.modelDepth[j],
            y_first=mval[ndx[0]],y_last=mval[ndx[-1]]);
        } else {
          pl.plot((dlo[ndx]+dhi[ndx])/2.0,mval[ndx];
            line=popt.mstyle[j],color=popt.mcolors[j],depth=popt.modelDepth[j]);
        }
      }
    }
  }
  return pl;
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% xfps_plot_res()
% Plots residuals on provided plot object
% TODO: clean this up and make it resemble xfps_plot_data() more.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
private define xfps_plot_res(pl,spec,popt) {
  variable j;
  _for j (0,length(spec.res)-1,1) {
    variable dlo,dhi,res,res_m,res_p;
    dlo = spec.dlo[j];
    dhi = spec.dhi[j];
    res = spec.res[j][0];
    res_m = spec.res_m[j][0];
    res_p = spec.res_p[j][0];
    pl.plot((dlo+dhi)/2.0,res,{dlo,dhi},{res_m,res_p};minmax,sym=popt.dsym[j],color=popt.colors[j],size=popt.symsize[j],depth=popt.dataDepth[j]);
  }
  pl.plot((dlo+dhi)/2.0,Double_Type[length(dlo)]+(popt.ratio?1.0:0.0);color="black",line=XFIG_LINESTYLE_DASHED,depth=min(popt.dataDepth)-1);
  return pl;
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% xfps_create_string_array()
% Initialize an array with a given value
% (mainly to do a String_Type[] array more easily)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
private define xfps_create_string_array(n,str) {
  variable arr = typeof(str)[n];
  variable i;
  _for i (0,n-1,1) arr[i] = str;
  return arr;
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% xfps_labels()
% Return appropriate labels for units
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
private define xfps_labels(unit) {
  variable labelArray;
  switch (unit)
  { case "kev" : labelArray = [XFPS_LABEL_X_KEV,XFPS_LABEL_Y_KEV]; }
  { case "a" : labelArray = [XFPS_LABEL_X_A,XFPS_LABEL_Y_A]; }
  { labelArray = ["UNRECOGNIZED UNITS: "+unit,"UNRECOGNIZED UNITS: "+unit]; }
  return labelArray;
}

#endif
